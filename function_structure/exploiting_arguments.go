package hangman

import (
	"fmt"
	"os"
)

// Handling arguments and adding values to Game structure parameters
func Arg() Game {
	var game Game
	arguments := os.Args[1:]
	needFile := true                    // If needFile is true, this means that the last argument given is an option requesting a file.
	for index, arg := range arguments { // Review all the arguments
		switch arg {
		case "--startWith", "-sw":
			if needFile && index != 0 {
				fmt.Println("Invalid argument")
				os.Exit(3)
			} else {
				needFile = true
			}
			game.save = true
			if len(arguments) > index+1 {
				game.saveFile = arguments[index+1] // The backup file is saved in game.SaveFile
			} else {
				fmt.Println("Invalid argument")
				os.Exit(3)
			}

		case "--classic", "-c":
			if needFile && index != 0 {
				os.Exit(3)
			} else {
				needFile = false
			}
			if game.ascii {
				fmt.Println("Two arguments not compatible")
				os.Exit(4)
			} else {
				game.classic = true
			}
		case "--ascii", "-a":
			if needFile && index != 0 {
				fmt.Println("Invalid argument")
				os.Exit(3)
			} else {
				needFile = false
			}
			if game.classic { // Cause GameAscii is not compatible with GameClassic
				fmt.Println("Two arguments not compatible")
				os.Exit(4)
			} else {
				game.ascii = true
			}
		case "--letterFile", "-lf":
			if needFile && index != 0 {
				fmt.Println("Invalid argument")
				os.Exit(3)
			} else {
				needFile = true
			}
			if game.classic { // Cause letterFile is not compatible with GameClassic
				fmt.Println("Two arguments not compatible")
				os.Exit(4)
			} else {
				game.letter = true
			}
			if len(arguments) > index+1 {
				game.letterFile = arguments[index+1] // The ascii art font file is saved in game.letterFile
			} else {
				fmt.Println("Invalid argument")
				os.Exit(3)
			}
		case "--rules", "-r":
			if index != 0 || len(arguments) != 1 {
				fmt.Println("Invalid argument")
				os.Exit(3)
			}
			Rules()
			os.Exit(0)
		case "--help", "-h":
			if index != 0 || len(arguments) != 1 {
				fmt.Println("Invalid argument")
				os.Exit(3)
			}
			Help()
			os.Exit(0)
		default:
			if needFile && index == 0 {
				game.dico = arguments[0]
			} else if !needFile {
				fmt.Println("Invalid argument")
				os.Exit(3)
			}
			needFile = false
		}
	}
	return game
}

// Using the arguments, generates HangManData's parameter values
func ExploitingArgument(game Game) {
	var data HangManData
	if game.save { // Set HangManData
		var err error
		data, err = Load("Ressources/Save/" + game.saveFile)
		if err != nil {
			fmt.Println("Error while loading the game state:", err)
			os.Exit(2)
		}
	} else {
		data.setData()
		dico := ReadTheDico(game.dico)
		data.SetWord(dico)
	}
	if !game.letter {
		game.letterFile = "standard.txt"
	} else {
		if game.letterFile != "standard.txt" && game.letterFile != "thinkertoy.txt" && game.letterFile != "shadow.txt" {
			fmt.Println("Unrecognized letterFile (i.e. letterFile will be standard.txt)\nPress enter to accept, otherwise ^C")
			var inputs string
			fmt.Scanln(&inputs)
		}
	}
	if game.classic {
		data.ClassicGame()
		os.Exit(0)
	}
	if game.ascii {
		data.AsciiGame(game)
		os.Exit(0)
	}
	data.TermBoxGame(game) // If no mode is launched, the default mode is TermboxGame
}
